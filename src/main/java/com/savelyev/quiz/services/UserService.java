package com.savelyev.quiz.services;

import com.savelyev.quiz.constants.ApplicationMessages;
import com.savelyev.quiz.exception.EntityNotFound;
import com.savelyev.quiz.exception.IncorrectTokenTypeException;
import com.savelyev.quiz.model.security.Role;
import com.savelyev.quiz.model.security.SecureToken;
import com.savelyev.quiz.model.security.TokenType;
import com.savelyev.quiz.model.security.User;
import com.savelyev.quiz.repositories.UserRepository;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.authentication.AnonymousAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import java.security.Principal;
import java.util.Collection;
import java.util.List;

@Service
@AllArgsConstructor
@Slf4j
public class UserService {

    private final UserRepository userRepository;

    private final SecureTokenService secureTokenService;
    private final EmailService emailService;

    private final RoleService roleService;
    private final BCryptPasswordEncoder passwordEncoder;


    public User findUserById(Long id) {
        log.info("Fetching user by id: {}",id);
        return userRepository.findById(id).orElseThrow(EntityNotFound::new);
    }

    public User findUserByName(String username) {
        log.info("Fetching user by name: {}", username);
        return userRepository.findUserByUsername(username)
                .orElseThrow(() ->
                        new UsernameNotFoundException(String.format("User '%s' not found", username)));
    }

    public User findUserByEmail(String email) {
        log.info("Fetching user by name {}", email);
        return userRepository.findUserByEmail(email)
                .orElseThrow(() ->
                        new UsernameNotFoundException(String.format("User with email '%s' not found", email)));
    }

    public boolean isAuthenticated() {
        final Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        return auth != null && auth.isAuthenticated() && !(auth instanceof AnonymousAuthenticationToken);
    }

    public boolean isUserExistByUsername(String username) {
        return userRepository.existsByUsername(username);
    }

    public boolean isUserExistByEmail(String email) {
        return userRepository.existsByEmail(email);
    }


    public void createUser(User user) {
        Collection<Role> roles = List.of(roleService.findRoleByRole("ROLE_USER"));
        user.setEnabled(false);
        user.setRoles(roles);
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        userRepository.save(user);
        log.info("Creating new user: {}", user);
    }

    public void updateUserPassword(User user) {
        log.info("{} changed password from profile page", user);
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        userRepository.save(user);
    }

    public void verifyUser(SecureToken token) throws IncorrectTokenTypeException {
        secureTokenService.checkTokenType(token, TokenType.EMAIL_CONFIRM);
        User user = token.getUser();
        user.setEnabled(true);
        userRepository.save(user);
        log.info("{} verified profile from email", user);
    }

    public void changePassword(SecureToken token, String password) throws IncorrectTokenTypeException {
        secureTokenService.checkTokenType(token, TokenType.PASSWORD_RESET);
        User user = token.getUser();
        user.setPassword(password);
        updateUserPassword(user);
        secureTokenService.deleteToken(token);
        log.info("{} changed password", user);
    }

    public void sendRegistrationConfirmationEmail(User user) {
        SecureToken secureToken = secureTokenService.generateVerifyToken(user);
        emailService.sendMail(user.getEmail(), ApplicationMessages.getEmailThemeMessage(), ApplicationMessages.getEmailVerificationEmailMessage()
                + "http://localhost:8080/verify/" + secureToken.getToken());
        log.info("token for email confirmation was generated by {}",user);
    }

    public void sendResetPasswordConfirmationEmail(User user) {
        SecureToken secureToken = secureTokenService.generatePasswordToken(user);
        emailService.sendMail(user.getEmail(), ApplicationMessages.getResetPasswordThemeMessage(), ApplicationMessages.getResetPasswordMessage()
                + "http://localhost:8080/reset/" + secureToken.getToken());

        log.info("token for password changing was generated by {}",user);
    }

    public User findUserByPrincipal(Principal principal) {
        return findUserByName(principal.getName());
    }

    public Page<User> getUsersRating(Pageable pageable) {
        return userRepository.ratingUsers(pageable);
    }

    public Long findUserRatingPlace(Long id) {
        return userRepository.getUsersRatingPlace(id);
    }

     public Page<User> findListUsersByName(String name, Pageable pageable){
       return userRepository.findUsersByUsername(name,pageable);
     }

}

